<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guitar Pro Score Viewer</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        /* 
           参考 ScoreViewer.vue 的结构和样式 
        */
        .score-wrapper {
            width: 100%;
            height: 100%;
            /* Ensure full height */
            flex: 1;
            overflow-x: hidden;
            overflow-y: auto;
            /* Scroll happens here */
            background: white;
            box-sizing: border-box;
            position: relative;
            /* For markers overlay */
        }

        .score-container {
            min-height: 100%;
            width: 100%;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        .markers-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        /* Loading Overlay */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        #loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            margin-top: 15px;
            color: #333;
            font-size: 14px;
        }

        .progress-bar {
            width: 200px;
            height: 4px;
            background: #eee;
            margin-top: 10px;
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #3498db;
            width: 0%;
            transition: width 0.3s;
        }

        /* Placeholder */
        #placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #888;
            z-index: 100;
            /* Ensure it is above score-wrapper background */
            pointer-events: none;
            /* Allow drag & drop through it */
        }

        #placeholder.hidden {
            display: none;
        }

        /* AlphaTab Styles copied from ScoreViewer.vue */
        .at-cursor-bar {
            background: rgba(255, 242, 0, 0.2) !important;
            will-change: left, top, width, height;
        }

        .at-cursor-beat {
            /* Background cursor: Blue Box */
            background: rgba(0, 123, 255, 0.35) !important;
            /* Width handled by AlphaTab to match internal scale */
            border-radius: 4px;
            margin-left: -2px;
            /* Center adjustment */
            will-change: left, top;
            z-index: 10;
        }

        .at-highlight * {
            fill: #42b883 !important;
            stroke: #42b883 !important;
        }
    </style>
    <!-- QWebChannel shim -->
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
</head>

<body>

    <div id="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text" id="loading-text">正在初始化...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>

    <div id="placeholder">
        <h2>拖入乐谱文件开始练习</h2>
        <p>支持 Guitar Pro (.gp3, .gp4, .gp5, .gpx)</p>
    </div>

    <!-- Structure matching ScoreViewer.vue -->
    <div class="score-wrapper" id="score-wrapper">
        <div id="score-container" class="score-container"></div>
        <div class="markers-overlay" id="markers-overlay"></div>
    </div>

    <script>
        // Global variables
        let api = null;
        let qtBridge = null;
        const wrapper = document.getElementById('score-wrapper');
        const container = document.getElementById('score-container');

        // ==== Utils ====
        function setLoadingStatus(text, progress) {
            const txt = document.getElementById('loading-text');
            const fill = document.getElementById('progress-fill');
            if (txt) txt.textContent = text;
            if (fill && progress !== undefined) fill.style.width = `${progress}%`;
        }

        function hideLoadingOverlay() {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) {
                overlay.classList.add('hidden');
                setTimeout(() => overlay.remove(), 500);
            }
        }

        // ==== Resource Path Logic ====
        function getResourcePath(type) {
            // Priority: Local (vendor/alphatab)
            const localBase = 'vendor/alphatab/';

            // We assume local files are now present and correct (1.8.1)
            // But we can keep CDN as fallback if needed, though for now we enforce local
            // to ensure offline reliability as per previous user issues.

            // Note: If running in QWebEngine, relative paths might need 'qrc://' or file:// logic 
            // but usually relative to the HTML file works if load request comes from there.
            // HTML is at src/ui/score_viewer.html
            // vendor is at root... wait.
            // PROJ_ROOT/src/ui/score_viewer.html
            // PROJ_ROOT/vendor/alphatab
            // So path should be ../../vendor/alphatab ?

            // Let's verify directory structure.
            // src/ui/score_viewer.html
            // src/ui/main_window.py
            // vendor/alphatab (at project root)

            // So relative path is indeed ../../vendor/alphatab/

            const relativeBase = '../../vendor/alphatab/';

            if (type === 'font') {
                return relativeBase + 'font/';
            } else if (type === 'soundfont') {
                return relativeBase + 'soundfont/sonivox.sf2';
            }
            return relativeBase;
        }

        // ==== Load AlphaTab ====
        function loadAlphaTabScript() {
            return new Promise((resolve, reject) => {
                setLoadingStatus('加载 AlphaTab 1.8.1 (本地)...', 10);

                // Relative path to vendor from src/ui/score_viewer.html
                const localPath = '../../vendor/alphatab/alphaTab.min.js';

                const script = document.createElement('script');
                script.onload = () => {
                    console.log('[AlphaTab] Local JS loaded successfully');
                    setLoadingStatus('核心库已就绪', 30);
                    resolve();
                };
                script.onerror = () => {
                    console.warn("Local load failed, trying CDN fallback...");
                    // Fallback to CDN just in case
                    const cdnPath = 'https://cdn.jsdelivr.net/npm/@coderline/alphatab@1.8.1/dist/alphaTab.min.js';
                    const fallback = document.createElement('script');
                    fallback.onload = () => {
                        console.log('[AlphaTab] CDN JS loaded');
                        setLoadingStatus('核心库已就绪 (CDN)', 30);
                        resolve();
                    };
                    fallback.onerror = () => reject(new Error('Failed to load AlphaTab (Local + CDN)'));
                    fallback.src = cdnPath;
                    document.head.appendChild(fallback);
                };
                script.src = localPath;
                document.head.appendChild(script);
            });
        }

        // ==== Python Bridge ====
        function setupQWebChannel() {
            new QWebChannel(qt.webChannelTransport, (channel) => {
                // Python: self.channel.registerObject('bridge', self.bridge)
                qtBridge = channel.objects.bridge;
                console.log('[Bridge] Connected to Python');

                // Initialize after bridge connection
                loadAlphaTabScript()
                    .then(() => {
                        initAlphaTab();
                    })
                    .catch(err => {
                        console.error(err);
                        sendEvent('error', { message: err.message });
                    });
            });
        }

        // Expose function to Python to request score data
        window.requestScoreData = function () {
            if (!api || !api.score) return;
            const events = getScoreData(api.score);
            sendEvent('scoreData', { events: events });
        };

        // ==== AlphaTab Property Helper (Returns the NAME of the property found) ====
        function getPropName(obj, names) {
            if (!obj) return undefined;
            for (const name of names) {
                if (obj[name] !== undefined) return name;
            }
            const keys = Object.keys(obj);
            for (const name of names) {
                const lower = name.toLowerCase();
                const fuzzy = keys.find(k => k.toLowerCase() === lower || k.toLowerCase().includes(lower));
                if (fuzzy) return fuzzy;
            }
            return undefined;
        }

        function getProp(obj, names) {
            const name = getPropName(obj, names);
            return name ? obj[name] : undefined;
        }

        // ==== AlphaTab Converters Cache ====
        const converterCache = {
            tickToMillis: null,
            millisToTick: null,
            lastScore: null
        };

        function resetConverterCache() {
            converterCache.tickToMillis = null;
            converterCache.millisToTick = null;
            converterCache.lastScore = null;
        }

        // ==== AlphaTab API Helper (Silent & Cached) ====
        function findConverter(api, name) {
            if (converterCache[name]) return converterCache[name];

            const msSteps = ['tickToMillis', 'tickToTime', 'getTickTime', 'timeConverter'];
            const tickSteps = ['millisToTick', 'timeToTick', 'getMillisTick', 'timeConverter'];
            const targets = (name.toLowerCase().includes('ticktomillis')) ? msSteps : tickSteps;

            const searchBases = [
                { obj: api, label: 'api' },
                { obj: api.score, label: 'api.score' },
                { obj: api.renderer, label: 'api.renderer' }
            ];

            for (const base of searchBases) {
                if (!base.obj) continue;
                for (const targetName of targets) {
                    let fn = null;
                    if (typeof base.obj[targetName] === 'function') {
                        fn = base.obj[targetName].bind(base.obj);
                    } else if (base.obj[targetName] && typeof base.obj[targetName][name] === 'function') {
                        fn = base.obj[targetName][name].bind(base.obj[targetName]);
                    }
                    if (fn) {
                        converterCache[name] = fn;
                        return fn;
                    }
                }
            }
            return null;
        }

        // Fallback: Physical Time Reconstruction (Base truth: 260.57s for Canon)
        function createFallbackConverter(score, toMillis) {
            if (!score || !score.masterBars || score.masterBars.length === 0) return null;
            const bars = score.masterBars;

            let bpm = 120;
            if (score.tempo) {
                if (typeof score.tempo === 'number') bpm = score.tempo;
                else if (typeof score.tempo.tempo === 'number') bpm = score.tempo.tempo;
                else if (typeof score.tempo.bpm === 'number') bpm = score.tempo.bpm;
            } else if (score.tracks && score.tracks[0] && score.tracks[0].tempo) {
                bpm = Number(score.tracks[0].tempo);
            }
            if (!bpm || isNaN(bpm)) bpm = 120;

            // AlphaTab standard ticks per quarter note
            const tpqn = score.ticksPerQuarterNote || 960;

            try {
                const s = bars[0], l = bars[bars.length - 1];
                const startProp = getPropName(bars[0], ['start', 'tickStart', 'absoluteStart']);
                sendEvent('debug', {
                    type: 'masterBarSample',
                    bpm: bpm,
                    tpqn: tpqn,
                    first: { start: s[startProp] },
                    last: { index: l.index, start: l[startProp] }
                });
            } catch (e) { }

            const secondsPerTick = (60.0 / bpm) / tpqn;
            const getTickTimeMs = (tick) => tick * secondsPerTick * 1000.0;

            if (toMillis) {
                const fn = (tick) => getTickTimeMs(tick);
                converterCache.tickToMillis = fn;
                return fn;
            } else {
                const fn = (ms) => Math.round((ms / 1000.0) / secondsPerTick);
                converterCache.millisToTick = fn;
                return fn;
            }
        }

        let isProcessingData = false; // Lock to prevent re-entry

        function getScoreData(score) {
            if (isProcessingData) {
                console.warn("[AlphaTab] getScoreData: Already processing data, skipping request.");
                return [];
            }
            const events = [];
            if (!score) return events;

            isProcessingData = true;
            console.log("[AlphaTab] getScoreData: Fetching note events...");

            isProcessingData = true;
            console.log("[AlphaTab] getScoreData: Fetching note events (STRICT PHYSICAL MODE)...");

            // FORCE physical calculation to avoid AlphaTab's 3.23s scaling issue
            const tickToMillis = createFallbackConverter(score, true);

            if (!tickToMillis) {
                console.error("[AlphaTab] No converter available.");
                isProcessingData = false;
                return events;
            }

            // Extracted BPM and TPQN for consistent scaling
            let bpm = 120;
            if (score.tempo) {
                if (typeof score.tempo === 'number') bpm = score.tempo;
                else if (typeof score.tempo.tempo === 'number') bpm = score.tempo.tempo;
                else if (typeof score.tempo.bpm === 'number') bpm = score.tempo.bpm;
            } else if (score.tracks && score.tracks[0] && score.tracks[0].tempo) {
                bpm = Number(score.tracks[0].tempo);
            }
            if (!bpm || isNaN(bpm)) bpm = 120;
            const tpqn = score.ticksPerQuarterNote || 960;

            const tracks = score.tracks || [];
            if (tracks.length === 0) { isProcessingData = false; return events; }

            const track = tracks[0];
            const tuning = track.tuning || [64, 59, 55, 50, 45, 40];
            const tuningLength = tuning.length;

            let bars = [];
            if (track.staves && track.staves.length > 0) {
                track.staves.forEach(stave => { if (stave.bars) bars = bars.concat(stave.bars); });
            } else if (track.bars) {
                bars = track.bars;
            }
            const barStartProp = getPropName(bars[0], ['start', 'tickStart', 'absoluteStart', 'startTick']) || 'start';
            console.log(`[AlphaTab] getScoreData: TPCN=${tpqn}, BPM=${bpm}, Bars=${bars.length}, OffsetProp=${barStartProp}`);

            let maxTime = 0;
            for (let i = 0; i < bars.length; i++) {
                const bar = bars[i];
                if (!bar) continue;

                // ABSOLUTE START: bar.masterBar.start is the standard in AlphaTab 1.x
                let bStart = 0;
                if (bar.masterBar) {
                    bStart = Number(getProp(bar.masterBar, ['start', 'tickStart', 'absoluteStart'])) || 0;
                } else {
                    bStart = Number(getProp(bar, ['start', 'tickStart', 'absoluteStart', 'startTick'])) || 0;
                }

                (bar.voices || []).forEach(voice => {
                    (voice.beats || []).forEach(beat => {
                        if (!beat || beat.isRest) return;

                        let beatTickRaw = getProp(beat, ['playbackStart', 'absoluteStart', 'start', 'tickStart', 'playbackStartVal']);
                        // beat.duration in AlphaTab is often an enum (1=Whole, 2=Half, 4=Quarter)
                        // It is NOT ticks. We must convert it.
                        let durationEnum = getProp(beat, ['durationValue', 'duration']); // 1, 2, 4, 8...

                        if (beatTickRaw === null || beatTickRaw === undefined) return;
                        let startTick = Number(beatTickRaw);

                        // PHYSICAL COMPENSATION: Use absolute ticks
                        if (startTick < bStart) startTick += bStart;

                        let durationTick = tpqn; // Default to quarter
                        if (typeof durationEnum === 'number' && durationEnum > 0) {
                            // Formula: Ticks = (4 * TPQN) / DurationEnum
                            // e.g. Quarter(4) -> (4 * 960) / 4 = 960 ticks
                            // Half(2) -> (3840) / 2 = 1920 ticks
                            durationTick = Math.round((4.0 * tpqn) / durationEnum);
                        } else {
                            // Fallback to existing logic if it might be an object
                            let durObj = getProp(beat, ['durationVal', 'duration', 'tickDuration']);
                            if (durObj && typeof durObj.ticks === 'number') durationTick = durObj.ticks;
                            else if (durObj && typeof durObj.playbackDuration === 'number') durationTick = durObj.playbackDuration;
                        }

                        try {
                            const rawStart = tickToMillis(startTick);
                            const rawEnd = tickToMillis(startTick + durationTick);

                            const startTime = rawStart / 1000.0;
                            const durSeconds = Math.max(0.01, (rawEnd - rawStart) / 1000.0);

                            if (events.length < 3) {
                                sendEvent('debug', {
                                    type: 'note_scaling_diagnostic_v3',
                                    index: events.length,
                                    bStart: bStart,
                                    tick: startTick,
                                    sec: startTime
                                });
                            }

                            if (startTime > maxTime) maxTime = startTime;

                            (beat.notes || []).forEach(note => {
                                if (note && note.string > 0 && note.string <= tuningLength) {
                                    const openStringMidi = tuning[note.string - 1];
                                    events.push([startTime, durSeconds, openStringMidi + (note.fret || 0), note.id]);
                                }
                            });
                        } catch (e) { }
                    });
                });
            }

            try {
                sendEvent('debug', {
                    type: 'events_sample',
                    lastMaxTime: maxTime,
                    sample: events.slice(-3)
                });
            } catch (e) { }

            console.log(`[AlphaTab] EXTRACTED: ${events.length} notes. Logical Duration: ${maxTime.toFixed(2)}s`);
            isProcessingData = false;
            return events;
        }

        window.markNote = function (noteId, color) {
            if (!noteId) return;
            const el = document.getElementById(noteId);
            if (el) {
                el.style.fill = color;
                el.style.stroke = color;
                const children = el.querySelectorAll('*');
                for (let i = 0; i < children.length; i++) {
                    children[i].style.fill = color;
                    children[i].style.stroke = color;
                }
            }
        };

        function sendEvent(event, data) {
            if (qtBridge) {
                qtBridge.onJsEvent(event, JSON.stringify(data || {}));
            }
        }

        window.setCursorTime = function (timeInSeconds) {
            if (!api) {
                console.warn("[AlphaTab] setCursorTime: API not initialized.");
                return;
            }
            let millisToTick = findConverter(api, 'millisToTick');
            if (!millisToTick) {
                millisToTick = createFallbackConverter(api.score, false);
            }
            if (!millisToTick) {
                console.error("[AlphaTab] setCursorTime: No millisToTick converter available.");
                return;
            }

            try {
                const tick = millisToTick(timeInSeconds * 1000);
                api.tick = tick;
            } catch (e) {
                console.error("setCursorTime error:", e);
            }
        };

        function initAlphaTab() {
            if (api) {
                api.destroy();
                api = null;
            }

            // Matches ScoreViewer.vue settings
            const settings = {
                // file: '', // Loaded later
                core: {
                    fontDirectory: getResourcePath('font'),
                    useWorkers: true
                },
                player: {
                    enablePlayer: true,
                    enableCursor: true,
                    enableAnimatedBeatCursor: false, // Turn off continuous movement
                    enableElementHighlighting: true,
                    soundFont: getResourcePath('soundfont'),
                    scrollElement: wrapper, // IMPORTANT: wrapper has overflow-y: auto
                    scrollSpeed: 10,        // Matches reference (10ms steps? or speed factor?)
                    scrollOffsetX: 0,
                },
                display: {
                    layoutMode: 'page', // Default vertical view
                    staveProfile: 'Tab', // Default to six-line staff
                    resources: {
                        // Ensure font is found
                        font: getResourcePath('font')
                    }
                }
            };

            console.log("Initializing AlphaTab with settings:", settings);

            try {
                // Global alphaTab object from window
                api = new alphaTab.AlphaTabApi(container, settings);

                // Signal readiness to Python immediately so it can send commands (like load score)
                setTimeout(() => {
                    sendEvent('ready');
                    // If no file loaded, we should hide overlay to show placeholder
                    // But we might want to keep it if we expect an immediate load?
                    // Usually correct to hide it and show "Drop file" placeholder.
                    hideLoadingOverlay();
                }, 100);

                // Events
                api.scoreLoaded.on((score) => {
                    console.log('Score loaded:', score.title);
                    sendEvent('scoreLoaded', {
                        title: score.title,
                        artist: score.artist,
                        tempo: score.tempo,
                        bars: score.masterBars.length
                    });

                    document.getElementById('placeholder').classList.add('hidden');
                    // Show loading again? Or assume playerReady comes soon?
                    // AlphaTab usually triggers scoreLoaded then playerReady.
                });

                api.playerReady.on(() => {
                    console.log('Player ready');
                    // sendEvent('ready'); // Moved up
                    sendEvent('playerReady');
                });

                api.playerFinished.on(() => {
                    sendEvent('playerFinished');
                });

                api.renderStarted.on(() => {
                    sendEvent('renderProgress', { progress: 10 });
                });

                api.renderFinished.on(() => {
                    sendEvent('renderProgress', { progress: 100 });
                });

                api.playerPositionChanged.on((e) => {
                    // e: { currentTime, endTime, currentTick, endTick }
                    sendEvent('positionChanged', {
                        currentTime: e.currentTime,
                        endTime: e.endTime,
                        currentTick: e.currentTick,
                        endTick: e.endTick
                    });
                });

                api.playedBeatChanged.on((beat) => {
                    // Send beat info
                    sendEvent('beatChanged', {
                        start: beat.start,
                        duration: beat.duration,
                        index: beat.index
                    });
                });

                api.error.on((e) => {
                    console.error('AlphaTab error:', e);
                    sendEvent('error', { message: e.message || 'Unknown error' });
                });

            } catch (e) {
                console.error("Error creating AlphaTab API:", e);
                sendEvent('error', { message: e.message });
            }
        }

        // ==== Public API (Called from Python) ====

        // 1. Load File (Base64 or Path? Python reads file and passes bytes usually, or pass path if local allowed)
        // ScoreView.py `load_file` uses `self.page().runJavaScript(f"loadScoreData('{base64_data}')")` or similar.
        // Let's check ScoreView.py.. it calls `api.load(data)`.

        // We need to expose helper functions globally for Python to call.

        window.loadScoreData = function (data, isFile = true) {
            // data can be byte array (from python list) or base64?
            // Usually AlphaTab auto-detects.
            if (api) {
                console.log("Loading score data...");
                try {
                    api.load(data);
                } catch (e) {
                    console.error("Load failed", e);
                }
            }
        };

        window.playPause = function () {
            if (api) api.playPause();
        };

        window.stop = function () {
            if (api) api.stop();
        };

        window.setSpeed = function (speed) {
            if (api) api.playbackSpeed = speed;
        };

        window.goToBar = function (barIndex) {
            // barIndex is 1-based
            if (!api || !api.score) return;
            if (barIndex < 1 || barIndex > api.score.masterBars.length) return;

            const bar = api.score.masterBars[barIndex - 1];
            api.tickPosition = bar.start;
            // Also move player?
            if (api.player) api.player.tickPosition = bar.start;
        };

        window.setStaveProfile = function (profile) {
            if (api) {
                api.settings.display.staveProfile = profile;
                api.updateSettings();
                api.render();
            }
        };

        window.setLayoutMode = function (mode) {
            if (api) {
                api.settings.display.layoutMode = mode; // 'page' or 'horizontal'
                api.updateSettings();
                api.render();
            }
        };

        window.zoomIn = function () {
            if (api) {
                api.settings.display.scale = (api.settings.display.scale || 1.0) + 0.1;
                api.updateSettings();
                api.render();
                // notify zoom changed?
            }
        };

        window.zoomOut = function () {
            if (api) {
                api.settings.display.scale = Math.max(0.5, (api.settings.display.scale || 1.0) - 0.1);
                api.updateSettings();
                api.render();
            }
        };

        window.zoomReset = function () {
            if (api) {
                api.settings.display.scale = 1.0;
                api.updateSettings();
                api.render();
            }
        };

        window.setZoom = function (scale) {
            if (api) {
                api.settings.display.scale = scale;
                api.updateSettings();
                api.render();
            }
        };

        // ==== Boot ====
        // Start QWebChannel if available, or just load specific debug mode
        if (typeof qt !== 'undefined') {
            setupQWebChannel();
        } else {
            // Debug mode without Python
            console.warn("No QT environment detected. Standalone mode.");
            loadAlphaTabScript().then(initAlphaTab);
        }

        // Drag and drop support
        document.addEventListener('dragover', e => {
            e.stopPropagation();
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        document.addEventListener('drop', e => {
            e.stopPropagation();
            e.preventDefault();
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (api) api.load(e.target.result);
                };
                reader.readAsArrayBuffer(file);
            }
        });

    </script>
</body>

</html>